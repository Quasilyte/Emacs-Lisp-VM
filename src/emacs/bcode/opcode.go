package bcode

// All opcode names are taken from Emacs sources directly.
// Some of them are not pretty, but it is better
// than alternative with partial renaming.
// Octal literals are used with the same rationale.
const (
	OpStackRef              byte = 0
	OpVarref                byte = 010 // Issue#3
	OpVarset                byte = 020 // Issue#3
	OpVarbind               byte = 030 // Issue#3
	OpCall                  byte = 040 // Issue#5
	OpUnbind                byte = 050 // Issue#3
	OpPopHandler            byte = 060 // Issue#7
	OpPushConditionCase     byte = 061 // Issue#7
	OpPushCatch             byte = 062 // Issue#7
	OpNth                   byte = 070
	OpSymbolp               byte = 071
	OpConsp                 byte = 072
	OpStringp               byte = 073
	OpListp                 byte = 074
	OpEq                    byte = 075
	OpMemq                  byte = 076
	OpNot                   byte = 077
	OpCar                   byte = 0100
	OpCdr                   byte = 0101
	OpCons                  byte = 0102
	OpList1                 byte = 0103
	OpList2                 byte = 0104
	OpList3                 byte = 0105
	OpList4                 byte = 0106
	OpLength                byte = 0107
	OpAref                  byte = 0110
	OpAset                  byte = 0111
	OpSet                   byte = 0114 // Issue#4
	OpFset                  byte = 0115 // Issue#5
	OpGet                   byte = 0116 // Issue#4
	OpSubstring             byte = 0117
	OpConcat2               byte = 0120
	OpConcat3               byte = 0121
	OpConcat4               byte = 0122
	OpSub1                  byte = 0123
	OpAdd1                  byte = 0124
	OpEqlsign               byte = 0125 // `=`
	OpGtr                   byte = 0126 // `>`
	OpLss                   byte = 0127 // `<`
	OpLeq                   byte = 0130 // `<=`
	OpGeq                   byte = 0131 // `>=`
	OpDiff                  byte = 0132 // `-`
	OpNegate                byte = 0133 // Negate number sign
	OpPlus                  byte = 0134
	OpMax                   byte = 0135
	OpMin                   byte = 0136
	OpMult                  byte = 0137 // `*`
	OpPoint                 byte = 0140 // Issue#4
	OpSaveCurrentBuffer     byte = 0141 // Issue#4
	OpGotoChar              byte = 0142 // Issue#4
	OpInsert                byte = 0143 // Issue#4
	OpPointMax              byte = 0144 // Issue#4
	OpPointMin              byte = 0145 // Issue#4
	OpCharAfter             byte = 0146 // Issue#4
	OpFollowingChar         byte = 0147 // Issue#4
	OpPrecedingChar         byte = 0150 // Issue#4
	OpCurrentColumn         byte = 0151 // Issue#4
	OpIndentTo              byte = 0152 // Issue#4
	OpEolp                  byte = 0154 // EOL; Issue#4
	OpEobp                  byte = 0155 // End of buffer; Issue#4
	OpBolp                  byte = 0156 // Beginning of line; Issue#4
	OpBobp                  byte = 0157 // Beginning of buffer; Issue#4
	OpCurrentBuffer         byte = 0160 // Issue#4
	OpSetBuffer             byte = 0161 // Issue#4
	OpSaveCurrentBuffer2    byte = 0162 // Issue#4
	OpInteractivep          byte = 0164 // Issue#5
	OpForwardChar           byte = 0165 // Issue#4
	OpForwardWord           byte = 0166 // Issue#4
	OpSkipCharsForward      byte = 0167 // Issue#4
	OpSkipCharsBackward     byte = 0170 // Issue#4
	OpForwardLine           byte = 0171 // Issue#4
	OpCharSyntax            byte = 0172 // Issue#6
	OpBufferSubstring       byte = 0173 // Issue#4
	OpDeleteRegion          byte = 0174 // Issue#4
	OpNarrowToRegion        byte = 0175 // Issue#4
	OpWiden                 byte = 0176 // Issue#4
	OpEndOfLine             byte = 0177 // Issue#4
	OpConstant2             byte = 0201
	OpGoto                  byte = 0202
	OpGotoIfNil             byte = 0203
	OpGotoIfNonNil          byte = 0204
	OpGotoIfNilElsePop      byte = 0205
	OpGotoIfNonNilRlsePop   byte = 0206
	OpReturn                byte = 0207
	OpDiscard               byte = 0210
	OpDup                   byte = 0211
	OpSaveExcursion         byte = 0212 // Issue#4
	OpSaveWindowExcursion   byte = 0213 // Issue#4
	OpSaveRestriction       byte = 0214 // Issue#4
	OpCatch                 byte = 0215 // Issue#7
	OpUnwindProtect         byte = 0216 // Issue#7
	OpConditionCase         byte = 0217 // Issue#7
	OpTempOutputBufferSetup byte = 0220 // Issue#4
	OpTempOutputBufferShow  byte = 0221 // Issue#4
	OpUnbindAll             byte = 0222 // Issue#3
	OpSetMarker             byte = 0223 // Issue#4
	OpMatchBeginning        byte = 0224 // Issue#4
	OpMatchEnd              byte = 0225 // Issue#4
	OpUpcase                byte = 0226
	OpDowncase              byte = 0227
	OpStringEqlsign         byte = 0230 // `string=`
	OpStringLss             byte = 0231 // `string<`
	OpEqual                 byte = 0232
	OpNthCdr                byte = 0233
	OpElt                   byte = 0234
	OpMember                byte = 0235
	OpAssq                  byte = 0236
	OpNreverse              byte = 0237
	OpSetcar                byte = 0240
	OpSetcdr                byte = 0241
	OpCarSafe               byte = 0242
	OpCdrSafe               byte = 0243
	OpNconc                 byte = 0244
	OpQuo                   byte = 0245 // `/`
	OpRem                   byte = 0246
	OpNumberp               byte = 0247
	OpIntegerp              byte = 0250
	OpRgoto                 byte = 0252 // Issue#8
	OpRgotoIfNil            byte = 0253 // Issue#8
	OpRgotoIfNonNil         byte = 0254 // Issue#8
	OpRgotoIfNilElsePop     byte = 0255 // Issue#8
	OpRgotoIfNonNilElsePop  byte = 0256 // Issue#8
	BlistN                  byte = 0257
	BconcatN                byte = 0260
	BinsertN                byte = 0261
	BstackSet               byte = 0262
	BstackSet2              byte = 0263
	BdiscardN               byte = 0266
	Bconstant               byte = 0300
)
